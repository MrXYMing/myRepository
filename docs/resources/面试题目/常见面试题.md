# 常见面试题

## HTML部分

#### 1.对HTML5的理解，Web语义化，SEO

#### 2.页面加载的过程

- 这个过程可简单的分为5步：
    1. 域名解析，根据域名找到服务器的IP地址；
    2. 建立TCP连接，浏览器与服务器经过3次握手后建立连接；
    3. 浏览器发起HTTP请求，获取想要的资源；
    4. 服务器响应HTTP请求，返回指定的资源；
    5. 浏览器渲染页面，解析接收到的HTML、CSS和JS文件。
    
**补充**
- 浏览器解析、加载页面(补充上述第5点)：
    1. 解析html构建dom树；
    2. 构建render树；
    3. 布局render树；
    4. 绘制render树。
- 浏览器为了体验友好，并不是文档全部都解析才绘制到屏幕上，而是从上至下开始解析html，遇到css会开启线程下载css(补充上述第2点)：
    1. 将HTML构建成一个DOM树（Document Object Model），DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点；
    2. 将CSS解析构造成CSSOM树(CSS Object Model);
    3. 根据DOM树和CSSOM树来构造Rendering Tree(渲染树)。*render树并不等同于DOM树，像Header或display:none这样的东西没必要放在渲染树中*；
    4. 有了Render树，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系；
    5. 计算出每个节点在屏幕中的位置 layout render tree；
    6. 绘制，即遍历render树，并使用浏览器UI后端层绘制每个节点。
    
**拓展1：重绘、重排**
- 性能优化中重绘、重排：
    1. Reflow(回流/重排)：当它发现了某个部分发生了变化影响了布局，渲染树需要重新计算；
    2. Repaint(重绘)：改变了某个元素的背景颜色、文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。
    3. Reflow要比Repaint更花费时间，也就更影响性能。所以要尽量避免过多的Reflow。
- reflow的原因：
    1. 页面初始化的时候；
    2. 操作DOM时；
    3. 某些元素的尺寸变了；
    4. 如果CSS的属性发生了变化。
- 减少reflow/repaint：
    1. 不要一条一条地修改DOM的样式，可以预先定义好css的class，然后修改DOM的className；
    2. 不要把DOM结点的属性值放在一个循环里当成循环里的变量；
    3. 为动画的HTML元件使用fixed或absolute的position，那么修改他们的CSS是不会reflow的；
    4. 不要使用table布局，因为可能很小的一个改动会造成整个table的重新布局。
    
**拓展2：影响页面渲染**
- css事项：
    1. dom深度尽量浅；
    2. 减少inline javascript、css的数量；
    3. 使用现代合法的css属性；
    4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素；
    5. 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}；
    6. 避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.
- js事项：
    1. 如果在解析html的时候遇到js会阻塞页面渲染，所以一般我们会将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染；
    2. 尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此；
    3. 采用无阻塞下载 JavaScript 脚本的方法：
        1. 使用script标签的 defer、async 属性；
        2. 使用动态创建的script元素来下载并执行代码等异步加载等方法。
- defer、async区别：
    defer、async都是异步下载，但是执行时刻不一致；
    - 相同点：
        1. 加载文件时不阻塞页面渲染；
        2. 使用这两个属性的脚本中不能调用document.write方法；
        3. 允许不定义属性值，仅仅使用属性名；
    - 不同点：
        1. html的版本html4.0中定义了defer，html5.0中定义了async；这将造成由于浏览器版本的不同而对其支持的程度不同；
        2. 每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行，所以就有可能出现脚本执行顺序被打乱的情况；
        3. 每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行；


#### 3.结构组织

#### 4.新增API(如本地存储、Canvas)

---

## CSS部分

#### 1.经典的圣杯布局

[参考链接](https://blog.csdn.net/wangchengiii/article/details/77926868)

**拓展：Flex布局**

[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

- 容器属性：
    1. flex-direction：主轴的方向(即项目的排列方向)：
        - row（默认值）：主轴为水平方向，起点在左端。
        - row-reverse：主轴为水平方向，起点在右端。
        - column：主轴为垂直方向，起点在上沿。
        - column-reverse：主轴为垂直方向，起点在下沿。
    2. flex-wrap：如果一条轴线派部下，如何换行：
        - nowrap(默认)：不换行；
        - wrap：换行；
        - wrap-reverse：换行，第一行在下方。
    3. flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值是 row nowrap：
        - &lt;flex-diretion> || &lt;flex-wrap>。
    4. justify-content：项目在主轴上的对齐方式：
        - flex-start（默认值）：左对齐
        - flex-end：右对齐
        - center： 居中
        - space-between：两端对齐，项目之间的间隔都相等。
        - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
    5. align-items：项目在交叉轴上如何对齐：
        - flex-start：交叉轴的起点对齐。
        - flex-end：交叉轴的终点对齐。
        - center：交叉轴的中点对齐。
        - baseline: 项目的第一行文字的基线对齐。
        - stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
    6. align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用：
        - flex-start：与交叉轴的起点对齐。
        - flex-end：与交叉轴的终点对齐。
        - center：与交叉轴的中点对齐。
        - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        - stretch（默认值）：轴线占满整个交叉轴。
- 项目属性：
    1. order：项目的排列顺序。数值越小，排列越靠前，默认为0.
    2. flex-grow：项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
    3. flex-shrink：项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
        负值对该属性无效。
    4. flex-basis：在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为 auto，即项目的本来大小。
        它可以设为跟 width 和 height 属性一样的值(如350px)，则项目将占据固定空间。
    5. flex：是flex-grow、flex-shrink和flex-basis属性的简写，默认值为 0 1 auto。后两个属性可选：
        flex: none | [ &lt;'flex-grow'> &lt;'flex-shrink'>? || &lt;'flex-basis'> ]
    6. align-self：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为 auto，表示继承父元素的align-items属性，如果没有父元素，则等同于 stretch。
        该属性可能去6个值，除了auto，其他都与align-items属性完全一致。

#### 2.CSS3属性(如transition、transform、animate)

#### 3.w3c盒子模型和IE盒子模型，box-sizing属性

#### 4.BFC

#### 5.优先级

#### 6.less与sass

#### 7.background-*系列属性

#### 8.水平垂直居中

#### 9.margin auto是怎么实现的，margin的实现原理

#### 10.什么是外边距塌陷？

    外边距塌陷也称为外边距合并；是指两个在正常文档流中相邻（兄弟或父子关系）的块级元素的外边距，组合在一起变成单个外边距，只有上下外边距才会塌陷。通常有4种情况会发生塌陷：
1. 父元素（没有上边框和上内边距）和第一个子元素，在第一个元素之前没有内容，同时为其定义了上外边距；
2. 父元素（没有下边框和下内边距）和最后一个子元素，在最后一个元素之后没有内容，同时为其定义了下外边距；
3. 两个相邻的兄弟元素，分别定义了下外边距和上外边距；
4. 一个空的元素（没有高、边框、内边距和内容），值定义了上下外边距。

- 当发生外边距塌陷时，外边距之间的计算方式是怎样的？
    1. 两个都是正数，取较大的值；
    2. 两个都是负数，取绝对值较大的值；
    3. 一正一负，取两个值相加的和。

---

## JS部分

#### 1.原型、原型链、闭包

- 闭包
    1. 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行；
    2. 一个函数在定义时的词法作用域之外的地方被调用，这个函数仍然持有对该作用域的引用，这个引用就叫做闭包；
    3. 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包；
    4. 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包。
    ```js
    function wait(message) {
        setTimeout( function timer() {
            console.log( message );
        }, 1000 );
    } 
    wait( "Hello, closure!" );
    //内置的工具函数 setTimeout(..) 持有对一个参数的引用， 这个参数也许叫作 fn 或者 func， 或者其他类似的名字。 引擎会调用这个函数， 在例子中就是内部的 timer 函数， 而词法作用域在这个过程中保持完整。这就是闭包。
    function setupBot(name, selector) {
        $( selector ).click( function activator() {
            console.log( "Activating: " + name );
        } );
    } 
    setupBot( "Closure Bot 1", "#bot_1" );
    setupBot( "Closure Bot 2", "#bot_2" );
    ```

#### 2.声明提升

我们习惯将 var a = 2; 看作一个声明， 而实际上 JavaScript 引擎并不这么认为。 它将 var a和 a = 2 当作两个单独的声明， 第一个是编译阶段的任务， 而第二个则是执行阶段的任务。

这意味着无论作用域中的声明出现在什么地方， 都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（ 变量和函数） 都会被“ 移动” 到各自作用域的最顶端， 这个过程被称为提升。

- 函数会首先被提升， 然后才是变量
```js
foo();
var foo;
function foo() {
    console.log( 1 );
} 
foo = function() {
    console.log( 2 );
}
//等同于
function foo() {
    console.log( 1 );
} 
foo(); // 1
foo = function() {
    console.log( 2 );
};
//重复的var声明会被忽略。出现在后面的函数声明可以覆盖前面的声明
```

#### 3.基本数据类型

#### 4.高阶函数

#### 5.JSON

#### 6.JSONP 跨域 iframe 通信

#### 7.Ajax

#### 8.原生DOM操作（比如 逆序DOM节点）

#### 9.事件捕捉，捕获，冒泡，代理

#### 10.Array常用函数

- 方法：

1. Array.from(arrayLike,?mapFn,?thisArg)：从类数组对象或者可迭代对象中创建一个新的数组实例:
    - arrayLike：想要转换成数组的伪数组对象或可迭代对象。
    - mapFn：可选参数，如果指定了该参数，新数组中的每个元素会执行该回调函数。
    - thisArg：可选参数，执行回调函数 mapFn 时 this 对象。
   ```js
   console.log(Array.from('foo'));
    // expected output: Array ["f", "o", "o"]

    console.log(Array.from([1, 2, 3], x => x + x));
    // expected output: Array [2, 4, 6]
    ```

2. Array.isArray(obj)：用来判断某个变量是否是一个数组对象。
    - obj：需要检测的值。
    ```js
    Array.isArray([1, 2, 3]);  
    // true
    Array.isArray({foo: 123}); 
    // false
    Array.isArray("foobar");   
    // false
    Array.isArray(undefined);  
    // false
    ```

3. Array.of(element0, ?element1, ?..., ?elementN)：根据一组参数来创建新的数组实例，支持任意的参数数量和类型。
    - 任elementN：意个参数，将按顺序成为返回数组中的元素。
    ```js
    Array.of(7);       // [7] 
    Array.of(1, 2, 3); // [1, 2, 3]

    Array(7);          // [ , , , , , , ]
    Array(1, 2, 3);    // [1, 2, 3]
    ```

##### 数组实例

- 修改器方法

`下面的这些方法会改变调用它们的对象自身的值：`

1. [Array.prototype.copyWithin(target,?start,?end)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)：在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。
    - 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。
    - 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。
    - 0 为基底的索引，开始复制元素的结束位置。如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）。
    ```js
    var array1 = ['a', 'b', 'c', 'd', 'e'];

    // copy to index 0 the element at index 3
    console.log(array1.copyWithin(0, 3, 4));
    // expected output: Array ["d", "b", "c", "d", "e"]

    // copy to index 1 all elements from index 3 to the end
    console.log(array1.copyWithin(1, 3));
    // expected output: Array ["d", "d", "e", "d", "e"]
    
    console.log(array1);
    // expected output: Array ["d", "d", "e", "d", "e"]
    ```

2. Array.prototype.fill(value,?start ,?end ) ：将数组中指定区间的所有元素的值，都替换成某个固定的值。
    - 用来填充数组元素的值。
    - 起始索引，默认值为0。
    - 终止索引，默认值为 this.length。
    ```js
    var array1 = [1, 2, 3, 4];

    // fill with 0 from position 2 until position 4
    console.log(array1.fill(0, 2, 4));
    // expected output: [1, 2, 0, 0]

    // fill with 5 from position 1
    console.log(array1.fill(5, 1));
    // expected output: [1, 5, 5, 5]

    console.log(array1.fill(6));
    // expected output: [6, 6, 6, 6]
    ```

3. Array.prototype.pop()：删除数组的最后一个元素，并返回这个元素。
4. Array.prototype.push(element1, ..., elementN)：在数组的末尾增加一个或多个元素，并返回数组的新长度。
5. Array.prototype.shift()：删除数组的第一个元素，并返回这个元素。
6. Array.prototype.unshift(element1, ..., elementN)：在数组的开头增加一个或多个元素，并返回数组的新长度。
7. Array.prototype.reverse()：颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。
8. [Array.prototype.sort(?compareFunction)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)：对数组元素进行排序，并返回当前数组。
9. Array.prototype.splice(start,?deleteCount,item1, item2, ... )：在任意的位置给数组添加或删除任意个元素。
    - 指定修改的开始位置（从0计数）
    - 整数，表示要移除的数组元素的个数。
    - 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。
    ```js
    var months = ['Jan', 'March', 'April', 'June'];
    months.splice(1, 0, 'Feb');
    // inserts at 1st index position
    console.log(months);
    // expected output: Array ['Jan', 'Feb', 'March', 'April', 'June']

    months.splice(4, 1, 'May');
    // replaces 1 element at 4th index
    console.log(months);
    // expected output: Array ['Jan', 'Feb', 'March', 'April', 'May']
    ```

##### 访问方法

`下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。`

1. Array.prototype.concat()：返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。
    - var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
    ```js
    var array1 = ['a', 'b', 'c'];
    var array2 = ['d', 'e', 'f'];

    console.log(array1.concat(array2));
    // expected output: Array ["a", "b", "c", "d", "e", "f"]
    ```

2. Array.prototype.includes(valueToFind[, fromIndex]) ：判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。
    - 需要查找的元素值
    - 从fromIndex 索引处开始查找 valueToFind。
    ```js
    var array1 = [1, 2, 3];

    console.log(array1.includes(2));
    // expected output: true

    var pets = ['cat', 'dog', 'bat'];

    console.log(pets.includes('cat'));
    // expected output: true

    console.log(pets.includes('at'));
    // expected output: false
    ```

3. Array.prototype.join([separator])：连接所有数组元素组成一个字符串。
    - 指定一个字符串来分隔数组的每个元素。

#### 11.String常用函数

#### 12.ES5 + ES6(用过哪些)

#### 13.框架部分（大部分按照简历来）

#### 14.Angular脏检查机制

[react diff算法](https://blog.csdn.net/qq_26708777/article/details/78107577)

#### 15.手写Angular指令，知道其生命周期

- vue 生命周期

- react 生命周期
    1. componentWillMount();
    2. reder();
    3. componentDidMount();
    4. ----
    5. componenWillReceiveProps();
    6. ----
    7. shouldComponentUpdate();
    8. componentWillUpdate();
    9. reder();
    10. componentDidUpdate();
    11. ----
    12. componentWillUnmount();


#### 16.手动实现MVC

#### 17.let var 区别，let是怎么实现的

#### 18.实现一个浅拷贝和深拷贝

---

## 衍生部分

#### 1.HTTP1/2 理解、状态码、优化、缓存控制（必考）

#### 2.TCP三次握手，四次挥手

#### 3.XSS与CSRF（必考）

[十大常见web漏洞及防范](https://blog.csdn.net/weixin_41656968/article/details/81270071)
    
[总结 XSS 与 CSRF 两种跨站攻击](https://www.cnblogs.com/wangyuyu/p/3388180.html)

#### 4.学习经历和方法

#### 5.性能优化

#### 6.单元测试

#### 7.React + Redux

#### 8.输入url会发生啥

#### 9.RXJS

#### 10.npm

#### 11.一些概念

[链接](https://github.com/MrXYMing/myRepository/blob/master/docs/diary/2018.07.md)

#### 12.函数防抖和节流

- 函数防抖：当数据短时间内一直变化，导致页面一直抖动的问题。常见于输入框输入动态显示数据的情况。

解决：可以通过setTimeout来处理，隔200ms左右再执行，只要这个函数一直在执行，就clearTimeout它，直到没有触发这事件为止，再执行最后触发的那一次。

```js
function debounce(func, delay) {
    var timeout;
    return function(e) {
        console.log("清除",timeout,e.target.value)
        clearTimeout(timeout);
        var context = this, args = arguments
        console.log("新的",timeout, e.target.value)
        timeout = setTimeout(function(){
          console.log("----")
          func.apply(context, args);
        },delay)
    };
};

var validate = debounce(function(e) {
    console.log("change", e.target.value, new Date-0)
}, 380);

// 绑定监听
document.querySelector("input").addEventListener('input', validate);
```

- 函数节流：跟函数防抖类似，但函数节流会用在比input、keyup更频繁触发的事件中，比如resize、touchmove、mousemove、scroll等事件中。

解决方法：保存上次执行的时间点和定时器，让用户的方法在某个时间段内只执行一次。

```js
function throttle(fn, threshhold) {
 var timeout
 var start = new Date;
 var threshhold = threshhold || 160
 return function () {

 var context = this, args = arguments, curr = new Date() - 0
 
 clearTimeout(timeout)//总是干掉事件回调
 if(curr - start >= threshhold){ 
     console.log("now", curr, curr - start)//注意这里相减的结果，都差不多是160左右
     fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次
     start = curr
 }else{
 //让方法在脱离事件后也能执行一次
     timeout = setTimeout(function(){
        fn.apply(context, args) 
     }, threshhold);
    }
  }
}
var mousemove = throttle(function(e) {
 console.log(e.pageX, e.pageY)
});

// 绑定监听
document.querySelector("#panel").addEventListener('mousemove', mousemove);
```
