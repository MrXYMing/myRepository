### 基础概念

至少在面试时能说得清楚是什么。

#### HTML5最新规范、HTML5特性；

1. 语义化的Web，让任何计算机更容易理解；
2. 消弱对第三方插件的依赖，以往播放音频或视频需要借助Flash，选择HTML5已原生支持多媒体；
3. 更丰富的应用：
    - 新增绘图元素canvas，可直接操纵图片、制作游戏和动态广告效果等；
    - 拓展JavaScript API，例如Web存储、地理定位、拖放、操纵历史浏览记录和读取文件等；
    - 创建离线Web程序，解决无网络时无法使用Web应用的情况；
    - 引入Web Workers规范，解决Web应用越来越复杂的计算；
4. 引进多种类型的新元素，例如构建文档的元素article、figure、header等，标识文本的元素mark、wbr等。

#### HTML语义化；

HTML5中的语义化就是让元素、属性或属性值有含义，更准确地标记特定类型地内容。对元素语义化地目的是让元素地语义和呈现分离，元素只负责文档内容地结构与含义，而CSS样式控制内容地呈现，像b元素，没有语义但能将字体变粗，这类元素违背了语义化的目的，将会被抛弃。

    [理解HTML语义化](https://www.cnblogs.com/fliu/articles/5244866.html)
    
#### Web Workers

1. 什么是Web Workers？

当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。

web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

所有主流浏览器均支持 web worker，`除了 IE`。

2. 实例

```js
<!DOCTYPE html>
<html>
<body>

<p>Count numbers: <output id="result"></output></p>
<button onclick="startWorker()">Start Worker</button>
<button onclick="stopWorker()">Stop Worker</button>
<br /><br />

<script>
    var w;

    function startWorker(){
        //检测 Web Worker 支持
        if(typeof(Worker)!=="undefined"){
            //创建 Web Worker 对象
            if(typeof(w)=="undefined"){
                w=new Worker("demo_workers.js");
            }
            //向 web worker 添加一个 "onmessage" 事件监听器：
            w.onmessage = function (event) {
                document.getElementById("result").innerHTML=event.data;
            };
        }else{
            document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers...";
        }
    }

    function stopWorker(){
        //终止 Web Worker
        w.terminate();
    }
</script>

</body>
</html>

//demo_workers.js
var i=0;

function timedCount(){
    i=i+1;
    postMessage(i);
    setTimeout("timedCount()",500);
}

timedCount();
```

以上代码中重要的部分是 `postMessage()` 方法 - 它用于向 HTML 页面传回一段消息。

#### Web存储

localStorage、seesionStorage、Cookie、indexedDB、userData；
**Web Storage**
1. localStorage

本地存储，永远不会过期，即使浏览器关闭，还会存在，同源地本地存储可以共享。

2. sessionStorage

会话存储，只能应用于页面会话期间，当关闭页面或浏览器地时候，会话存储中地数据就会被自动清除。

```js
//在第一张页面中设置两种存储方式
localStorage.setItem('local','local data');
sessionStorage.setItem('session','session data');

//在另一张页面中输出存储地数据
var local = localStorage.getItem('local'),
    session = sessionStorage.getItem('session');
```

*Web Storage End*

3. IndexedDB

IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。

一个单独的数据库项目的大小没有限制。然而可能会限制每个 IndexedDB 数据库的大小。这个限制（以及用户界面对它进行断言的方式）在各个浏览器上也可能有所不同。

4. userData

针对IE6、IE7，微软单独提供了userData实现本地存储。它是一种持久化存储方式，因此即使关闭了浏览器也不会清除这些数据，但可以设置失效日期。userData能根存储1MB左右的数据。userData将数据寄存在HTML元素中。

5. Cookie

cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。

```js
//简单用法
document.cookie = "name=oeschger";
document.cookie = "favorite_food=tripe";
console.log(document.cookie);
// 显示: name=oeschger;favorite_food=tripe
```

Cookie的缺陷：
- Cookie可以指定过期时间（Expire），可以将登录的用户名和密码等存储到cookie中，下次登录可省去重新输入，简化了流程。但这个网站中的每个HTTP请求都会带上这些cookie信息，增加了HTTP首部的内容，如果网站访问量巨大，将会影响宽带；
- Cookie不适合存储一些隐私或敏感信息（例如用户名、密码等），因为Cookie会在网络中传递，很容易被劫持，劫持后可以伪造请求，执行一些危险操作（例如删除或修改信息）。CSRF（跨站请求伪造）就是通过劫持Cookie的方式进行攻击的；
- Cookie的大小被浏览器限制在4KB左右，只能存储简单的信息，不能应对复杂的存储需求，例如缓存表单信息、数据同步等。有些表单要输入的项特别多，需要花费时间填写，但在填写过程中，有可能会因为误操作而将页面关闭。如果把表单信息缓存了起来，那么在重新打开页面时可为表单中的控件自动填充内容，不必重新输入。数据同步是指当网络突然断开时，将数据缓存起来，待到网络恢复后，再将缓存的数据与服务器同步，避免了数据丢失。

6. 用什么方法可以防止Cookie被盗取？

Cookie是先由浏览器向服务器发起请求，再由服务器响应后回传Ser-Cookie首部（此时可设置HttpOnly属性）向客户端浏览器写入Cookie。在给Cookie设置HttpOnly属性后，就能够禁止页面的js访问这个Cookie，从而避免被盗取。

#### [操纵历史浏览记录](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

- `History.pushState(state,title,url)`：按指定的名称和URL（如果提供该参数）将数据push进会话历史栈，数据被DOM进行不透明处理
    - state — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。
    - title - Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的state传递一个短标题。
    - url - 该参数定义了新的历史URL记录。

```js
let stateObj = {
    foo: "bar",
};

history.pushState(stateObj, "page 2", "bar.html");
```

- `popstate事件`：当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。

需要注意的是调用`history.pushState()`或`history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件`，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）

```js
window.onpopstate = function(event) {
  alert("location: " + document.location + ", state: " + JSON.stringify(event.state));
};
history.pushState({page: 1}, "title 1", "?page=1");
history.pushState({page: 2}, "title 2", "?page=2");
history.replaceState({page: 3}, "title 3", "?page=3");
history.back(); // alerts "location: http://example.com/example.html?page=1, state: {"page":1}"
history.back(); // alerts "location: http://example.com/example.html, state: null
history.go(2);
```

#### 内存泄漏

- [什么是内存泄漏](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)？

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

`不再用到的内存，没有及时释放，就叫做内存泄漏`（memory leak）。

- 常见内存泄漏原因
    1. 意外的全局变量；
    2. 被遗忘的计时器或回调；
    3. 超出DOM引用；
    4. 闭包；
    5. dom清空或删除时，事件未清除导致的内存泄漏；
    

#### [理解web标准（ES6标准，必学）](http://es6.ruanyifeng.com/#docs/intro)；
    1. let、const；
    2. Module（import、export）；
    3. class、extends、supper；
    4. arrow functions（箭头函数）；
    5. template string（模板字符串）；
    6. destructuring（解构）；
    7. default函数默认参数；
    8. rest arguments（rest参数）；
    9. spread operator（展开运算符）；
    10. Promise；
    11. Generators（迭代器）；
    12. Map；
    13. Set；
    14. [ES7-ES8-ES9-新特性](https://tuobaye.com/2018/11/27/%E7%BB%86%E8%A7%A3JavaScript-ES7-ES8-ES9-%E6%96%B0%E7%89%B9%E6%80%A7/)
        1. es7：
            1. Array.prototype.includes()方法；
            ```js
            ['a', 'b', 'c', 'd'].includes('b')         // true
            ['a', 'b', 'c', 'd'].includes('b', 1)      // true
            ['a', 'b', 'c', 'd'].includes('b', 2)      // false
            ```
            2. 求幂运算符（**）：
            ```js
            4 ** 3           // 64
            //效果等同于
            Math.pow(4,3);
            //**还支持以下操作
            let n = 4;
            n **= 3;
            // 64
            ```
        2. es8:
            1. 异步函数 Async Functions（Brian Terlson）;
            2. 共享内存和Atomics（Lars T. Hansen）;
            3. ---
            4. Object.values / Object.entries（Jordan Harband）;
            5. String padding（Jordan Harband，Rick Waldron）;
            6. Object.getOwnPropertyDescriptors() （Jordan Harband，Andrea Giammarchi）;
            7. 函数参数列表和调用中的尾逗号（Jeff Morrison）;
        3. es9:
            1. 异步迭代（Domenic Denicola，Kevin Smith）;
            2. Rest/Spread 属性（SebastianMarkbåge）;
            3. ---
            4. RegExp named capture groups（Gorkem Yakin，Daniel Ehrenberg）;
            5. RegExp Unicode Property Escapes（Mathias Bynens）;
            6. RegExp Lookbehind Assertions（Gorkem Yakin，NozomuKatō，Daniel Ehrenberg）;
            7. s (dotAll) flag for regular expressions（Mathias Bynens）;
            8. ---
            9. Promise.prototype.finally() （Jordan Harband）;
            10. 模板字符串修改（Tim Disney）;

#### js面向对象编程方法；
#### css3新特性；

1. 完善了选择器（包括属性、关系、伪类、伪元素）；
2. 新增阴影、圆角、Web字体、渐变，能替代以往得用图像才能实现的效果，这样既能减少HTTP请求数，还能提升页面加载速度；
3. 对背景不再局限于颜色、填充方式、定位，现在可以一次性使用多张背景图、控制背景尺寸、裁剪背景图像等；
4. 引入了过渡和动画两个属性，可处理简单或复杂的样式变化，不仅能让页面生动真实，还能摆脱对flash的依赖，远离大段地js脚本；
5. 新增两种全新地布局：多列布局（grid）和伸缩盒（flex-box）；
6. 可让元素进行2D或3D变形，包括旋转、移动、缩放、扭曲。在动画中使用3D地变形会新增一个渲染层，将重绘（页面渲染地一个环节）减少到一次，提升动画性能。

#### css3动画，及css3相关；

#### es6，require.js，amd；

#### [版本控制](https://www.cnblogs.com/allanli/p/git_commands.html)；

- `安装Git`
    - git config user.name [AAA]
    - git config user.email [邮箱地址]
    - git config --global user.name "Your Name"
    - git config --global user.email "email@example.com"
- `创建版本库`
    - git init //初始化本地git环境
    - git add . //把本地的修改加到stage中
    - git commit -m 'comments here' //把stage中的修改提交到本地库
- `查看修改`
    - git status //查看当前分支有哪些修改
    - git diff //查看当前没有add的内容
- `版本回退`
    - git log //查看当前分支上面的日志信息（显示从最近到最远的提交日志）
    - git reset --hard HEAD //撤销本地修改
    - git reflog  //查看命令历史，可以查看到每次提交的commit id，用来配合git reset --hard commit_id来返回到回退前的版本
- `撤销修改`
    - git checkout -- file  //可以丢弃工作区的修改
- `删除文件`
    - git rm file //从版本库中删除该文件。可以用 git checkout -- file 把误删的文件恢复到最新版本（只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容）。
- `添加远程库`
    - git remote add origin git@github.com:账号/learngit.it  //关联一个远程库(远程库的名字就是origin)
    - git push -u origin master  //第一次推送master分支的所有内容
- `从远程库克隆`
    - git clone XXX//克隆一份代码到本地仓库
- `创建与合并分支`
    - git checkout -b dev //创建+切换分支。git checkout命令加上-b参数表示创建并切换
    - git branch name // 创建分支
    - git branch //查看分支
    - git checkout name //切换分支
    - git merge name //合并某分支到当前分支
    - git branch -d name //删除分支
- `解决冲突`
    - git log --graph --pretty=oneline --abbrev-commit  //查看分支的合并情况
- `Bug分支`
    - git stash //可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
    - git stash list //查看所有的缓存
    - git stash pop //恢复本地分支到缓存状态，同时把stash内容删除
- `功能分支`
    - git branch -D name  //分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数
- `多人协作`
    - git remote  //查看远程库的信息（当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin）
    - git remote -v  //显示更详细的信息
    - git push origin branch-name  //推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上
    - git checkout -b branch-name origin/branch-name  //在本地创建和远程分支对应的分支
    - git pull  //把远程库的代码更新到工作台
    - git branch --set-upstream-to branch-name origin/branch-name //创建本地分支和远程分支的链接关系
- `Rebase`
    - git rebase  //可以把本地未push的分叉提交历史整理成直线；
- `创建标签`
    - git tag name //可以在需要打标签的分支上打一个新标签
    - git tag name commit_id //对提交过的commit打分支
    - git tag  //查看标签
    - git tag -a name -m "version 0.1 released" commit_id //创建带有说明的标签，用-a指定标签名，-m指定说明文字：
    - git show tagname  //查看标签信息（标签不是按时间顺序列出，而是按字母排序的）
- `操作标签`
    - git push origin tagname  //推送某个标签到远程（创建的标签都只存储在本地，不会自动推送到远程）
    - git push origin --tags //一次性推送全部尚未推送到远程的本地标签
    - git tag -d v0.1 //删除标签
    - git push origin :refs/tags/v0.9  //从远程删除
- `自定义Git`
    - git config --global color.ui true  //让Git显示颜色，会让命令输出看起来更醒目
    - .gitignore文件  //把要忽略的文件名填进去，Git就会自动忽略这些文件。
- `额外`
    - git blame someFile //查看某个文件的每一行的修改记录（）谁在什么时候修改的）
    - echo $HOME //查看git config的HOME路径
    - export $HOME=/c/gitconfig //配置git config的HOME路径
    - ---
- [廖雪峰-Git](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000)
    - git add 的具体使用：
        - git add -A  提交所有变化
        - git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)
        - git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件
    - git diff的具体使用：
        - git diff readme.txt //查看对readme.txt作了什么修改
        - git diff --cache //查看已经add但是没有commit的内容
        - git diff HEAD //上面两个内容的合并
    - git reset --hard HEAD的具体使用：
        - HEAD 表示当前版本（指向当前分支）；
        - HEAD^ 表示上一个版本；
        - HEAD^^ 表示上上一个版本；
        - HEAD~100 表示上100个版本；
        - git reset --hard 1094a //返回回退前commit id是1094adb...的版本
        - git reset HEAD file //把暂存区的修改撤销掉（unstage），重新放回工作区
        - git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。
    - git checkout的具体使用：
        - git checkout master/branch //切换到某个分支
        - git checkout -- file //文件在工作区的修改全部撤销：让这个文件回到最近一次git commit或git add时的状态。
        - git checkout -b test //新建test分支
        - git checkout -d test //删除test分支
    - git push的具体使用： //把本地库的修改提交到远程库中
        - `git push -u origin master`：把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
        - git push origin master：把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！
    - git branch的具体使用：
        - git branch //查看当前分支
        - git branch dev //创建分支
        - git branch -r/-a //查看远程分支/全部分支
    - git stash的具体使用：
        - git stash  //把未完成的修改缓存到栈容器中
        - git stash list //查看所有的缓存
        - git stash pop //恢复本地分支到缓存状态，同时把stash内容删除
        - git stash apply  //恢复本地分支到缓存状态，但是恢复后，stash内容并不删除
        - git stash drop  //删除本地分支的缓存状态
    - git pull的具体使用：
        - git pull --rebase origin name //强制把远程库的代码跟新到当前分支上面
        - git fetch相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并git fetch是更好的选择。效果相同时git pull将更为快捷。[参考资料](https://www.cnblogs.com/qiu-Ann/p/7902855.html)
    - git remote的具体使用：
        - git remote  //查看远程库的信息
        - git remote -v  //显示更详细的信息
        - git remote add origin git@gitee.com:liaoxuefeng/learngit.git  //关联远程库
        - git remote rm origin //删除已有的Github远程库

#### HTTP协议、https、http2；

    [TCP/IP、HTTP、HTTPS、HTTP2.0](https://www.cnblogs.com/w1570631036/p/8119747.html)

#### webpack；

- 核心概念：
    1. Entry：入口，Webpack执行构建的第一步将从Entry开始，可抽象成输入；
    2. Module：模块，在Webpack里一切皆模块，一个模块对应着一个文件，Webpack会从配置的Entry开始递归找出所有依赖的模块；
    3. Chunk：代码块，一个Chunk由多个模块组合而成，用于代码合并与分割；
    4. Loader：模块转换器，用于把模块原内容按照需求转换成新内容；
    5. Plugin：拓展插件，在Webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情；
    6. Output：输出结果，在Webpack经过一系列处理并得出最终想要的代码后输出结果。
    
> Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。

#### sass；
#### typescript；
#### state；

  [Redux入门教程（快速上手）](https://segmentfault.com/a/1190000011474522)
    
  [redux原来如此简单](https://segmentfault.com/a/1190000016311891)

#### rxjs；
#### canvas；


#### 数据mock；
#### 前后端分离（客户端渲染，数据渲染交给前端来做）；

#### 抽象类、接口

> 用于限定某个对象所必须拥有的公共操作方法的一种结构，称之为接口（interface）
> 
>只要一个类里面有一个方法是抽象方 法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明 为抽象类，使用“abstract”来修饰。

什么是抽象方法？我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方 
法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后 
加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰； 例如： 
```js
abstract function fun1(); 
```

接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。

抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。

当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。

[接口和抽象类有什么区别](http://www.cnblogs.com/yongjiapei/p/5494894.html)

[继承、覆盖、重载与多态](https://www.cnblogs.com/jeknight/p/6941088.html)

#### JS的OOP

[Javascript 面向对象编程（一）：封装](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)

[Javascript面向对象编程（二）：构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)

[Javascript面向对象编程（三）：非构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)

- 浅拷贝

```js
var Chinese = {
    nation:'中国'
};
var Doctor ={
    career:'医生'
}

function extendCopy(p) {
    var c = {};
    for (var i in p) {
        c[i] = p[i];
    }
    c.uber = p;
    return c;
}
//使用
var Doctor = extendCopy(Chinese);
Doctor.career = '医生';
console.log(Doctor.nation); // 中国
```

浅拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。

```js
Chinese.birthPlaces = ['北京','上海','香港'];
var Doctor = extendCopy(Chinese);
Doctor.birthPlaces.push('厦门');
console.log(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
console.log(Chinese.birthPlaces); //北京, 上海, 香港, 厦门
```

- 深拷贝

递归调用"浅拷贝"就行了

```js
var Chinese = {
    nation:'中国'
};
var Doctor ={
    career:'医生'
}

function deepCopy(p, c) {
    var c = c || {};
    for (var i in p) {
        if (typeof p[i] === 'object') {
            c[i] = (p[i].constructor === Array) ? [] : {};
            deepCopy(p[i], c[i]);
        } else {
            c[i] = p[i];
        }
    }
    return c;
}
//使用
var Doctor = deepCopy(Chinese);
Chinese.birthPlaces = ['北京','上海','香港'];
Doctor.birthPlaces.push('厦门');
console.log(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
console.log(Chinese.birthPlaces); //北京, 上海, 香港
```
