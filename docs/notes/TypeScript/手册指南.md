## 接口
```
interface SquareConfig {
  color?: string;
  width?: number;
}
```
### readonly VS const
最简单判断该使用readonly还是const的方法是看要把它作为变量使用还是作为一个属性。作为变量使用的话用const，作为属性的话用readonly。

### 额外的属性检查
```
function createSquare(config: SquareConfig): { color: string } {
    // ...
}

// error: 'colour' not expected in type 'SquareConfig'
let mySquare = createSquare({ colour: "red", width: 100 });
```

- 最简单的方法：可使用`类型断言`来绕开这些检查 
```
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

- 最佳的方式：添加一个`字符串索引签名`：
```
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
``` 

表示 SquareConfig 可以有任意数量的属性，而且只要它们不是 color 和 width ，那么就无所谓他们的类型是什么。

### 函数类型
为了使用接口表示函数类型，我们需要给接口定义一个`调用签名`。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。
```
interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result > -1;
}

let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result > -1;
}
```

对于函数的参数名不需要与接口里定义的名字相匹配。函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果没有制定类型，ts的类型系统会推断出参数类型。如果函数返回值的类型和接口要求的返回值类型不匹配，类型检查器会警告我们函数的返回值类型和接口中的定义不匹配。

## 类
### 继承
```
class Animal {
    name:string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);

--------------
Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
```

用`extends`关键字来创建子类，可以看到 Horse 和 Snake 类是基类 Animal 的子类，并且可以访问其属性和方法。包含构造函数的派生类必须调用`super()`，它会执行基类的构造方法。
在子类里可以重写父类的方法， Snake 类和 Horse 类都创建了move 方法，他们重写了从 Animal 继承来的 move 方法，是的 move 方法根据不同的类而具有不同的功能。
注意，即使 tom 被声明为 Animal 类型，但因为他的值是 Horse ，tom.move(34)会调用Horse里的重写方法。

