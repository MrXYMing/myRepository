# JavaScript高级程序设计3

## 第一章 JavaScript简介

### 1.2 JavaScript实现：

一个完整的JavaScript实现应该由三个不同的部分组成：

- 核心（ECMAScript）;
- 文档对象模型（DOM）；
- 浏览器对象模型（BOM）。

### 1.2.1 ECMAScript：

由ECMA-262定义的ECMAScript与Web浏览器没有依赖关系，Web浏览器只是ECMAScript实现可能的`宿主环境`之一，其他宿主环境包括Node和Adobe Flash。宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的拓展--如DOM，是利用ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。

ECMA-262规定了这门语言的下列组成部分：

- 语法；
- 类型；
- 语句；
- 关键字；
- 保留字；
- 操作符；
- 对象。

### 1.2.2 文档对象模型（DOM）

DOM是针对XML但经过拓展用于HTML的应用程序编程接口。DOM把整个页面映射为一个多层节点结构，HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。

### 1.2.3 浏览器对象模型（BOM）

从根本上将，BOM只处理浏览器窗口和框架，但人们习惯上把所有针对浏览器的js拓展算作BOM的一部分，一些这样的拓展：

- 弹出新浏览器窗口的功能；
- 移动、缩放和关闭浏览器窗口的功能；
- 提供浏览器详细信息的navigator对象；
- 提供浏览器所加载页面的详细信息的location对象；
- 提供用户显示器分辨率详细信息的screen对象；
- 对cookies的支持；
- 想XMLHttpRequest和IE的ActiveXObject这样的自定义对象。

---

### 1.4 小结

- ECMAcript：由ECMA-262定义，提供核心语言功能；
- 文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
- 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。

---
---

## 第二章 在HTML中使用JavaScript

### 2.1 \<script>元素

属性：

- async：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
- charset：可选，表示通过src属性指定的字符集。大多数浏览器会忽略它的值，因此很少有人用这个属性。
- defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行。支队外部脚本文件有效。IE7及更早版本对嵌入脚本也支持这个属性。
- language：已废弃，原来用于表示编写代码使用的脚本语言。
- src：可选，表示包含要执行代码的外部文件。
- type：可选，表示编写代码使用的脚本语言的内容类型。text/javascript 和 text/acmascript 都已不被推荐使用。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x-javasctipt，但在type中设置这个值却可能导致脚本被忽略。

在使用\<script>元素嵌入JavaScript代码时，只需为\<script>指定type属性 type="text/javascript"。

在使用\<script>嵌入JavaScript代码时，不要在代码中的任何地方出现“<\/script>”字符串，因为按照解析嵌入式代码的规则，当浏览器遇到字符串“<\/script>”时，就会认为那是结束的标签，通过转义字符，来将代码分成两部分来写就会造成浏览器的误解了：`<\/script>`。

#### 2.1.1 标签的位置

在文档的`<head>`元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成后，才能开始呈现页面的内容（浏览器遇到\<body>标签时才开始呈现内容）。

#### 2.1.2 延迟脚本

\<script>标签定义的defer属性，是用来表明脚本在执行时不会影响页面的构造，也就是说，脚本会被延迟到整个页面都解析完毕后再运行。`<script defer="defer">`相当于告诉浏览器立即下载，但延迟执行。

在现实中，延迟脚本并不一定会按照顺序执行，也不一定会子啊DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。

IE4、Firefox3.5、Safari5和Chrome是最早支持defer属性的浏览器，其他浏览器会忽略这个属性，支持HTML的实现也会忽略嵌入脚本设置的defer属性，想平常一样处理脚本。因此，把延迟脚本放在页面底部仍然是最佳选择。

---

### 2.3 文档模式

- 混杂模式：会让IE的行为与（包含非标准特性的）IE5相同；
- 标准模式：让IE的行为更接近标准行为；

这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到js的解释执行。

- 准标准模式：这种模式下的浏览器特性有很多都是符合标准的，但也不尽然，不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。

如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。

---

### 2.4 \<noscripe>元素

这个元素可以包含能够出现在文档\<body>中的任何HTML元素--\<script>元素除外。只有在浏览器不支持脚本；或者浏览器支持脚本，但脚本被禁用的情况下才会显示出来。

```html
<body>
    <noscript>
        <p>本页面需要浏览器支持（启用）JavaScript</p>
    </noscript>
</body>
```

---
---

## 第三章 基本概念

### 3.1 语法

#### 3.1.1 区分大小写

ECMAScript中的一切（变量、函数名、操作符）都区分大小写。变量名test和变量名Test分别表示两个不同的变量；typeof不能用作函数名，因为他是要给关键字，但typeOf完全是要给有效的函数名。

#### 3.1.2 标识符

标识符指的是变量、函数、属性的名字，或者函数的参数；按下列格式规则组合起来的一或多个字符：

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

#### 3.1.4 严格模式

`"use strict";`

---

### 3.4 数据类型

5种简单（基础）数据类型：

1. Undefined;
2. Null;
3. Boolean;
4. Number;
5. String;

1种复杂数据类型

1. Object。

#### 3.4.1 typeof操作符

- "undefined"：如果这个值未定义；
- "boolean"：  如果这个值是布尔值；
- "string"：如果这个值是字符串；
- "number"：如果这个值是数值；
- "object":如果这个值是对象或null；
- "function"：如果这个值是函数。

注意：*Safari5及之前版本、Chrome7及之前版本在对正则表达式调用typeof操作符时会返回"function"，而其他浏览器会返回"object"。从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。*

#### 3.4.2 Undefined类型

在使用var声明变量但未对其加以初始化时，这个变量的值就是undefiend。

对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没有实际意义，而且在严格模式下会导致错误）。

**注意：**对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样会返回undefined：

```js
var message;
//var age
alert(typeof message); //"undefined"
alert(typeof age);     //"undefined"
```

#### 3.4.3 Null类型

从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回"object"的原因。

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用。

**PS：**实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。`alert(null == undefined);  // true`

尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。

#### 3.4.4 Boolean类型

Boolean类型只有两个字面值：true和false，是区分大小写的。也就是说，True和False（以及其他的混合大小写形式）都不是Boolean值，只是标识符。

```js
var a = True;
console.log(a); //ReferenceError: True is not defined
```

调用转型函数`Boolean()`可以将一个值转换为其对应的Boolean值。
|数据类型  |转换为true的值                      |转换为false的值|
|:---|:---|:---|
|Boolean  |true                                | false   |
|String   |任何非空字符串                       | ""(空字符串)|
|Number   |任何非零数字值(包括无穷大)            |0和NaN|
|Object   |任何对象                             | null|
|Undefined|n/a(是not applicable的缩写，“不适用”) |undefined|

注意：*流控制语句(如if语句)中，会自动执行相对应的Boolean转换："var message = 'hello world!; if(message){alert('value is true');}'"*

#### 3.4.5 Number类型

八进制字面值的第一位必须是零(0)，后跟任何八进制数字序列(0~7)，如果字面值超出了范围，你们前导零将被忽略，后面的数值将被当作十进制数值解析。

```js
var num1 = 070;  //八进制的56
var num2 = 079;  //无效的八进制数值--解析为79；
```

十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0~9及A~F)。其中A~F可以大写也可以小写。

```js
var num1 = 0xA;   //十六进制的10
var num2 = 0x1f;  //十六进制的31
```

在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值：

```js
070+070 = 112;     //八进制的56+56
0x99+0x99 = 306;   //十六进制的153+153
070+0x99 = 209;
```

ps:*可以保存正零(+0)和负零(-0)，正零和负零被认为是相等的（包括恒等）。*

- 1.浮点数值

浮点数值就是该数值中必须包含一个小数点，并且小数点后面至少有一位数字。小数点前面可以没有整数，但是不推荐省略。

如果小数点后面没有跟任何数字，那么ECMAScript会将浮点数值转换为整数值；同样的，如果浮点数值本身表示的就是一个整数(如1.0)，那么该值也会被转换为整数：

```js
var num1 = 1.;    //小数点后面没有数字--解析为1
var num2 = 10.0;  //整数--解析为10
```

对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。用e表示法表示的数值等于e前面的数值乘以10的指数次幂。即前面是一个数值（整数/浮点数），中间是一个大写或小写的e，后面是10的幂中的指数：

```js
var num1 = 3.125e7; //等于31250000 
var num2 = 3e-17;   //等于0.00000000000000003
```

浮点数值的最高精度是17位小数，但在进行算数计算时精确度远远不如整数。例如，`0.1加0.2的结果不是0.3，而是0.30000000000000004`。因此，**`永远不要测试某个特定的浮点数值`**。

```js
if(a + b ==0.3){          //不要做这样的测试
    alert("You got 0.3.");
}
```

ps:*关于浮点数值计算会产生误差的问题，是使用基于IEEE754数值的浮点计算的通病，其他使用相同数据格式的语言也存在这个问题。*

- 2.数值范围

ECMAScript能够表示的最小数值保存在`Number.MIN_VALUE`中--在大多数浏览器中，这个值是`5e-324`；能够表示的最大数值保存在`Number.MAX_VALUE`中--在大多数浏览器中，这个值是`1.7976931348623157e+308`。

如果某次计算的结果得到一个超出js数值范围的值，那么这个数值将被自动转换成特殊的`Infinity`值，如果是负数，会被转换成 -Infinity(负无穷)，如果是正数，会被转换成Infinity(正无穷)。如果某次计算返回了Infinity值，那么该值将无法继续参与下一次计算，因为Infinity不是能够参与计算的数值。`isFinite()`函数可以确定一个数值是不是有穷的(位于最小和最大数值之间)。

ps:*访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。*

- 3.NaN

即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN（其他编程语言会导致错误），因此不会影响其他代码的执行。

NaN有两个特点：1. 任何涉及NaN的操作（例如NaN/10）都会返回NaN；2. NaN与任何值都不相等，包括NaN本身。

`isNaN()`函数，接受一个参数，该参数可以是任何类型，帮我们确认这个参数是否“不是数值”。

```js
alert(isNaN(NaN));    //true
alert(isNaN(10));     //false(10是一个数值)
alert(isNaN("10"));   //false(可以被转换成数值10)
alert(isNaN("blue")); //true(不能转换成数值)
alert(isNaN(true));   //false(可以被转换成数值1)
```

isNaN()也适用于对象。会首先`调用对象的valueOf()`方法，然后确认该对象返回的值是否可以转换为数值。如果不能，则`基于这个返回值再调用toString()`方法，再测试返回值。*PS：这个过程也是ECMAScript中内置函数和操作符的一般执行流程。*

- 4.数值转换

    - Number():可以用于任何数据类型转换成数值；转换规则如下：
        1. 如果是Boolean值，true和false分别转换成1和0；
        2. 如果是数字值，只是简单的传入和返回；
        3. 如果是null值，返回0；
        4. 如果是undefined，返回NaN；
        5. 如果是字符串，遵循如下规则：
            1. 只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，“1”-1，“123”-123，“011”-11（前导的零会被忽略）；
            2. 包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（也忽略前导零）；
            3. 包含有效的十六进制格式，如“0xf”，则将其转换为相同大小的十进制整数；
            4. 空字符串（不包含任何字符），则将其转换为0；
            5. 包含除上述格式之外的字符，则将其转换为NaN。
        6. 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

    - paresInt():专门用于把字符串转换成数值。

        paresInt()转换字符串时，更多的是看其是否符合数值模式，它会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，就会返回NaN；（转换空字符串会返回NaN，Number()对空字符串返回0）。如果第一个字符是数字，会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。注意，因为小数点不是有效的数字字符，所以类似的“22.5”会转换成22.

        如果字符串中的第一个字符是数字字符，parseInt()也是能够识别出各种整数格式："0x"开头且后跟数字字符，会当作十六进制整数；"0"开头且后跟数字字符，则会当作八进制数。

        ```js
        parseInt("1234blue"); //1234
        parseInt("");         //NaN
        parseInt("0xA");     //10（十六进制数）
        parseInt(22.5);      //22
        parseInt("070);      //56（八进制数）
        pareInt("70");       //70
        parseInt("0xf");     //15（十六进制数）
        ```

        parseInt()解析想八进制字面量的字符串时，ECMAScript3和5存在分歧：

        ```js
        parseInt("070");    //56（ECMAScript3认为是八进制）
                            //70（ECMAScript5认为是十进制）
        ```
        为消除上述困惑，parseInt()提供第二个参数：转换时使用的基数（即多少进制）。

        ```js
        parseInt("0xAF",16)  //175
        parseInt("AF",16)    //175
        parseInt("AF")       //NaN
        ```
        **为了避免错误的解析，应该无论什么情况下，都明确指定基数。** *ps：大多数情况下我们解析的都是十进制数值，所以始终将10作为第二个参数是非常必要的*

    - parseFloat()：专门用于把字符串转换成数值。

        parseFloat()也是从第一个字符开始解析每个字符，一直解析到字符串末尾或者解析到遇见一个无效的浮点数字字符为止。即第一个小数点是有效的，而第二个小数点是无效的，他后面的字符串会被忽略。

        除第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。因此十六进制格式的字符串始终会被转换成0，它只解析十进制整数格式，因此它没有用第二个参数指定基数的用法。

        如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

        ```js
        parseFloat("1234blue");    //1234
        parseFloat("0XA");         //0
        parseFloat("22.5.34.5");   //22.5
        parseFloat("0908.5");      //908.5
        parseFloat("3.125e7");     /31250000
        ```

#### 3.4.6 String类型

- 1.字符字面量

String数据类型包含一些特殊的字符字面量，也叫转义序列。
|字面量 | 含义 |
|:---|:---|
|\n    |换行  |
|\t    |制表  |
|\b    |空格  |
|\r    |回车  |
|\f    |进纸  |
|\\\   |斜杠  |
|\'    |单引号：'He Said,\'hey.\''  |
|\''   |双引号："He Said,\"hey.\""  |
|\xnn  |以十六进制代码nn表示的一个字符（其中n为0~F）。例如：\x41 表示"A"  |
|\unnnn|以十六进制代码nnnn表示的要给Unicode字符（其中n为0~F）。例如：\u03a3表示希腊字符Σ  |

这些字符字面量可以出现在字符串中的任意位置，并且会被作为一个字符来解析。例如：

```js
var text = "this is the letter sigma: \u03a3.";
alert(text.length);  //输出28
```

这里的变量text有28个字符，其中6个字符长的转义序列表示一个字符。**注意：**length属性返回的字符数包括16位字符的数目，如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。

- 2.字符串的特点

ECMAScript中的字符串的值一旦创建就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量，例如：

```js
var lang = "Java";
lang = lang + "Script";
```

在执行组合操作的过程中，首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"。**注意：**这个过程是在后台发生的，所以这也是在某些旧版本的浏览器（FireFox1.0以下，IE6等）中拼接字符串时速度很慢的原因。

- 3.转换为字符串
    1. `toString()`方法

    ```js
    var found = true;
    var foundAsString = found.toString();   //字符串“true”
    ```
    数值、布尔值、对象和字符串（返回字符串的一个副本）都有toString()方法，但null和undefined值没有。

    toString()可以传递一个参数：输出数值的基数。默认以十进制格式返回数值的字符串表示。

    2. 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数`String()`，它遵循以下转换规则：
        1. 如果值由toString()方法，则调用该方法（没有参数）并返回相应的结果；
        2. 如果值是null，则返回"null"；
        3. 如果值是undefined，则返回"undefined"。

    PS:*要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（""）加在一起。*

#### 3.4.7 Object类型

对象其实就是一组数据和功能的集合。对象可以通过执行`new`操作符后跟要创建的对象类型的名称来创建。不推荐省略圆括号。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object的每个实例都具有下列属性和方法：

- Constructor：保存着用于创建当前对象的函数。

```js
var a = function(){};
var b = new a();
console.log(b.constructor);  //function a()
```

- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。作为参数的属性名（propertyName）必须以字符串形式制定。
- isPrototypeOf(object)：用于检查传入的对象是否是领域给对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in与来枚举。propertyName必须以字符串形式指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

ps:*在ECMAScript中Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法。*

ps:*ECMA-262中对象的行为不一定适用于js中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。*

---

### 3.5 操作符

操作符在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。

#### 3.5.1 一元操作符

只能操作一个值得操作符叫做一元操作符。

- 1.递增和递减操作符

在应用于不同的值时，++和--操作符遵循下列规则：

1. 在应用于包含有效数字字符的字符串时，先将其转换为数字值在执行加减1的操作，字符串变量变成数值变量；
2. 在应用于不包含有效数字字符的字符串时，将变量的值设置为NsN，字符串变量变成数值变量；
3. 在应用于布尔值false时，先将其转换为0再执行加减1的操作，布尔值变量变成数值变量；
4. 在应用于布尔值true时，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量；
5. 在应用于浮点数值时，执行加减1的操作；
6. 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值，然后对该值应用前述规则；如果结果是NaN，则再调用toString()方法后再应用前述规则，对象变量变成数值变量。

```js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};
s1++;  //值变成数值3
s2++;  //值变成数值NaN
b++;  //值变成数值1
f--;  //值变成数值0.1000000000000009(由于浮点舍入错误所致)
o--;  //值变成数值-2
```

- 2.一元加和减操作符

一元加和减操作符主要用于基本的算数运算，也可以用于转换数据类型。在转换数据类型时，以一个加号(+)或减号(-)放在变量前面，应用一元加操作符时，与递增遵循的规则一致；应用一元减操作符时，遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。

#### 3.5.2 位操作符

1. 按位非(~)；
2. 按位与(&)；
3. 按位或(|)；
4. 按位异或(^)；
5. 左移(<<)；
6. 有符号的右移(>>)；
7. 无符的号右移(>>>)；

#### 3.5.3 布尔操作符

- 1.逻辑非(!)

逻辑非都会返回一个布尔值，首先会将它的操作数转换为一个布尔值，然后再对其求反；遵循以下规则：

1. 如果操作数是一个对象，返回false；（即 Boolean({}); //true）
2. 如果操作数是一个空字符串，返回true；
3. 如果操作数是一个非空字符串，返回false；
4. 如果操作数是数值0，返回true；
5. 如果操作数是任意非0数值（包括Infinity），返回false；
6. 如果操作数是null，返回true；
7. 如果操作数是NaN，返回true；
8. 如果操作数是undefined，返回true。

ps:*！！两个逻辑非操作符会模拟Boolean()转型函数的行为，最终结果与对这个值使用Boolean()函数相同。*

- 2.逻辑与(&&)

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第二个操作数；
2. 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
3. 如果两个操作数都是对象，则返回第二个操作数；
4. 如果有一个操作数是null，则返回null；
5. 如果有一个操作数是NaN，则返回NaN；
6. 如果有一个操作数是undefined，则返回undefined。

```js
//3
var b = {} && {a:1};
console.log(b);
>>Object { a: 1 }
//6.
var aa;var bbb= (true && aa);
console.log(bbb)
>>undefined
```

`逻辑与操作属于短路操作`，即如果第一个操作数能够决定结果，那么久不会再对第二个操作数求值。对于逻辑与而言，如果第一个操作数是false，则结果必定是false，不会再对&&右侧的操作数求值了。

**注意**不能在逻辑与操作中使用未定义的值，会导致错误。

```js
var q = (true && w);
console.log(q);
>>ReferenceError: w is not defined
```

- 3.逻辑或(||)

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第一个操作数；
2. 如果第一个操作数的求值结果为false，则返回第二个操作数；
3. 如果两个操作数都是对象，则返回第一个操作数；
4. 如果两个操作数都是null，则返回null；
5. 如果两个操作数都是NaN，则返回NaN；
6. 如果两个操作数都是undefined，则返回undefined。

逻辑或也是短路操作符，即如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

#### 3.5.4 乘性操作符

- 1.乘法(*)

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的乘法计算，如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity与0相乘，则结果是NaN；
4. 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
5. 如果是Infinity与Infinity相乘，则结果是Infinity；
6. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

- 2.除法(/) 被除数/除数=商

在处理特殊值的情况下，除法操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的除法计算，如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity被Infinity除，则结果是NaN；
4. 如果是0被0除，则结果是NaN；
5. 如果是非0的有限数被0除（1/0=Infinity），则结果是Infinity或-Infinity，取决于有符号操作数的符号；
6. 如果是Infinity被任何非零数值除（Infinity/1=Infinity），则结果是Infinity或-Infinity，取决于有符号操作数的符号；
7. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

- 3.求模/求余(%) 被除数/除数=余数

在处理特殊值的情况下，求模操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
2. 如果被除数是无穷大值而除数是有限大的数值（Infinity%0=NaN），则结果是NaN；
3. 如果被除数是有限大的数值而除数是0，则结果是NaN；
4. 如果是Infinity被Infinity除，则结果是NaN；
5. 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
6. 如果被除数是0，则结果是0；
7. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 3.5.5 加性操作符

- 1.加法(+)

如果两个操作数都是数值，执行常规的加法计算，然后根据下列规则返回结果：

1. 如果有一个操作数是NaN，则结果是NaN；
2. 如果是Infinity加Infinity，则结果是Infinity；
3. 如果是-Infinity加-Infinity，则结果是-Infinity；
4. 如果是Infinity加-Infinity，则结果是NaN；
5. 如果是+0加+0，则结果是+0；
6. 如果是-0加-0，则结果是-0；
7. 如果是+0加-0，则结果是+0。

如果有一个操作数是字符串，则应用如下规则：

1. 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来；

如果有一个操作数是对象、数值或布尔值，则调用他们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null ，则分别调用String()函数并取得字符串"undefined"和"null"。

- 2.减法(-)

减法操作在处理各种数据类型转换时，同样需要遵循一些特殊规则：

1. 如果两个操作数都是数值，则执行常规的算数减法操作并返回结果；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity减Infinity，则结果是NaN；
4. 如果是-Infinity减-Infinity，则结果是NaN；
5. 如果是Infinity减-Infinity，则结果是Infinity；
6. 如果是-Infinity减Infinity，则结果是-Infinity；
7. 如果是+0减+0，则结果是+0；
8. 如果是+0减-0，则结果是-0；
9. 如果是-0减-0，则结果是+0；
10. 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果是NaN；
11. 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值，如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

#### 3.5.6 关系操作符

