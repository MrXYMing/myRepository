# JavaScript高级程序设计3

## 第三章 基本概念

### 3.1 语法

#### 3.1.1 区分大小写

ECMAScript中的一切（变量、函数名、操作符）都区分大小写。变量名test和变量名Test分别表示两个不同的变量；typeof不能用作函数名，因为他是要给关键字，但typeOf完全是要给有效的函数名。

#### 3.1.2 标识符

标识符指的是变量、函数、属性的名字，或者函数的参数；按下列格式规则组合起来的一或多个字符：

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

#### 3.1.4 严格模式

`"use strict";`

---

### 3.4 数据类型

5种简单（基础）数据类型：

1. Undefined;
2. Null;
3. Boolean;
4. Number;
5. String;

1种复杂数据类型

1. Object。

#### 3.4.1 typeof操作符

- "undefined"：如果这个值未定义；
- "boolean"：  如果这个值是布尔值；
- "string"：如果这个值是字符串；
- "number"：如果这个值是数值；
- "object":如果这个值是对象或null；
- "function"：如果这个值是函数。

注意：*Safari5及之前版本、Chrome7及之前版本在对正则表达式调用typeof操作符时会返回"function"，而其他浏览器会返回"object"。从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。*

#### 3.4.2 Undefined类型

在使用var声明变量但未对其加以初始化时，这个变量的值就是undefiend。

对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没有实际意义，而且在严格模式下会导致错误）。

**注意**：对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样会返回undefined：

```js
var message;
//var age
alert(typeof message); //"undefined"
alert(typeof age);     //"undefined"
```

#### 3.4.3 Null类型

从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回"object"的原因。

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用。

**PS**：实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。`alert(null == undefined);  // true`

尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。

#### 3.4.4 Boolean类型

Boolean类型只有两个字面值：true和false，是区分大小写的。也就是说，True和False（以及其他的混合大小写形式）都不是Boolean值，只是标识符。

```js
var a = True;
console.log(a); //ReferenceError: True is not defined
```

调用转型函数`Boolean()`可以将一个值转换为其对应的Boolean值。
|数据类型  |转换为true的值                      |转换为false的值|
|:---|:---|:---|
|Boolean  |true                                | false   |
|String   |任何非空字符串                       | ""(空字符串)|
|Number   |任何非零数字值(包括无穷大)            |0和NaN|
|Object   |任何对象                             | null|
|Undefined|n/a(是not applicable的缩写，“不适用”) |undefined|

注意：*流控制语句(如if语句)中，会自动执行相对应的Boolean转换："var message = 'hello world!; if(message){alert('value is true');}'"*

#### 3.4.5 Number类型

八进制字面值的第一位必须是零(0)，后跟任何八进制数字序列(0~7)，如果字面值超出了范围，你们前导零将被忽略，后面的数值将被当作十进制数值解析。

```js
var num1 = 070;  //八进制的56
var num2 = 079;  //无效的八进制数值--解析为79；
```

十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0~9及A~F)。其中A~F可以大写也可以小写。

```js
var num1 = 0xA;   //十六进制的10
var num2 = 0x1f;  //十六进制的31
```

在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值：

```js
070+070 = 112;     //八进制的56+56
0x99+0x99 = 306;   //十六进制的153+153
070+0x99 = 209;
```

ps:*可以保存正零(+0)和负零(-0)，正零和负零被认为是相等的（包括恒等）。*

- 1.浮点数值

浮点数值就是该数值中必须包含一个小数点，并且小数点后面至少有一位数字。小数点前面可以没有整数，但是不推荐省略。

如果小数点后面没有跟任何数字，那么ECMAScript会将浮点数值转换为整数值；同样的，如果浮点数值本身表示的就是一个整数(如1.0)，那么该值也会被转换为整数：

```js
var num1 = 1.;    //小数点后面没有数字--解析为1
var num2 = 10.0;  //整数--解析为10
```

对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。用e表示法表示的数值等于e前面的数值乘以10的指数次幂。即前面是一个数值（整数/浮点数），中间是一个大写或小写的e，后面是10的幂中的指数：

```js
var num1 = 3.125e7; //等于31250000 
var num2 = 3e-17;   //等于0.00000000000000003
```

浮点数值的最高精度是17位小数，但在进行算数计算时精确度远远不如整数。例如，`0.1加0.2的结果不是0.3，而是0.30000000000000004`。因此，**`永远不要测试某个特定的浮点数值`**。

```js
if(a + b ==0.3){          //不要做这样的测试
    alert("You got 0.3.");
}
```

ps:*关于浮点数值计算会产生误差的问题，是使用基于IEEE754数值的浮点计算的通病，其他使用相同数据格式的语言也存在这个问题。*

- 2.数值范围

ECMAScript能够表示的最小数值保存在`Number.MIN_VALUE`中--在大多数浏览器中，这个值是`5e-324`；能够表示的最大数值保存在`Number.MAX_VALUE`中--在大多数浏览器中，这个值是`1.7976931348623157e+308`。

如果某次计算的结果得到一个超出js数值范围的值，那么这个数值将被自动转换成特殊的`Infinity`值，如果是负数，会被转换成 -Infinity(负无穷)，如果是正数，会被转换成Infinity(正无穷)。如果某次计算返回了Infinity值，那么该值将无法继续参与下一次计算，因为Infinity不是能够参与计算的数值。`isFinite()`函数可以确定一个数值是不是有穷的(位于最小和最大数值之间)。

ps:*访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。*

- 3.NaN

即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN（其他编程语言会导致错误），因此不会影响其他代码的执行。

NaN有两个特点：1. 任何涉及NaN的操作（例如NaN/10）都会返回NaN；2. NaN与任何值都不相等，包括NaN本身。

`isNaN()`函数，接受一个参数，该参数可以是任何类型，帮我们确认这个参数是否“不是数值”。

```js
alert(isNaN(NaN));    //true
alert(isNaN(10));     //false(10是一个数值)
alert(isNaN("10"));   //false(可以被转换成数值10)
alert(isNaN("blue")); //true(不能转换成数值)
alert(isNaN(true));   //false(可以被转换成数值1)
```

isNaN()也适用于对象。会首先`调用对象的valueOf()`方法，然后确认该对象返回的值是否可以转换为数值。如果不能，则`基于这个返回值再调用toString()`方法，再测试返回值。*PS：这个过程也是ECMAScript中内置函数和操作符的一般执行流程。*

- 4.数值转换

    - Number():可以用于任何数据类型转换成数值；转换规则如下：
        1. 如果是Boolean值，true和false分别转换成1和0；
        2. 如果是数字值，只是简单的传入和返回；
        3. 如果是null值，返回0；
        4. 如果是undefined，返回NaN；
        5. 如果是字符串，遵循如下规则：
            1. 只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，“1”-1，“123”-123，“011”-11（前导的零会被忽略）；
            2. 包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（也忽略前导零）；
            3. 包含有效的十六进制格式，如“0xf”，则将其转换为相同大小的十进制整数；
            4. 空字符串（不包含任何字符），则将其转换为0；
            5. 包含除上述格式之外的字符，则将其转换为NaN。
        6. 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

    - paresInt():专门用于把字符串转换成数值。

        paresInt()转换字符串时，更多的是看其是否符合数值模式，它会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，就会返回NaN；（转换空字符串会返回NaN，Number()对空字符串返回0）。如果第一个字符是数字，会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。注意，因为小数点不是有效的数字字符，所以类似的“22.5”会转换成22.

        如果字符串中的第一个字符是数字字符，parseInt()也是能够识别出各种整数格式："0x"开头且后跟数字字符，会当作十六进制整数；"0"开头且后跟数字字符，则会当作八进制数。

        ```js
        parseInt("1234blue"); //1234
        parseInt("");         //NaN
        parseInt("0xA");     //10（十六进制数）
        parseInt(22.5);      //22
        parseInt("070);      //56（八进制数）
        pareInt("70");       //70
        parseInt("0xf");     //15（十六进制数）
        ```

        parseInt()解析想八进制字面量的字符串时，ECMAScript3和5存在分歧：

        ```js
        parseInt("070");    //56（ECMAScript3认为是八进制）
                            //70（ECMAScript5认为是十进制）
        ```
        为消除上述困惑，parseInt()提供第二个参数：转换时使用的基数（即多少进制）。

        ```js
        parseInt("0xAF",16)  //175
        parseInt("AF",16)    //175
        parseInt("AF")       //NaN
        ```
        **为了避免错误的解析，应该无论什么情况下，都明确指定基数。** *ps：大多数情况下我们解析的都是十进制数值，所以始终将10作为第二个参数是非常必要的*

    - parseFloat()：专门用于把字符串转换成数值。

        parseFloat()也是从第一个字符开始解析每个字符，一直解析到字符串末尾或者解析到遇见一个无效的浮点数字字符为止。即第一个小数点是有效的，而第二个小数点是无效的，他后面的字符串会被忽略。

        除第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。因此十六进制格式的字符串始终会被转换成0，它只解析十进制整数格式，因此它没有用第二个参数指定基数的用法。

        如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

        ```js
        parseFloat("1234blue");    //1234
        parseFloat("0XA");         //0
        parseFloat("22.5.34.5");   //22.5
        parseFloat("0908.5");      //908.5
        parseFloat("3.125e7");     /31250000
        ```

#### 3.4.6 String类型

- 1.字符字面量

String数据类型包含一些特殊的字符字面量，也叫转义序列。
|字面量 | 含义 |
|:---|:---|
|\n    |换行  |
|\t    |制表  |
|\b    |空格  |
|\r    |回车  |
|\f    |进纸  |
|\\\   |斜杠  |
|\'    |单引号：'He Said,\'hey.\''  |
|\''   |双引号："He Said,\"hey.\""  |
|\xnn  |以十六进制代码nn表示的一个字符（其中n为0~F）。例如：\x41 表示"A"  |
|\unnnn|以十六进制代码nnnn表示的要给Unicode字符（其中n为0~F）。例如：\u03a3表示希腊字符Σ  |

这些字符字面量可以出现在字符串中的任意位置，并且会被作为一个字符来解析。例如：

```js
var text = "this is the letter sigma: \u03a3.";
alert(text.length);  //输出28
```

这里的变量text有28个字符，其中6个字符长的转义序列表示一个字符。**注意**：length属性返回的字符数包括16位字符的数目，如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。

- 2.字符串的特点

ECMAScript中的字符串的值一旦创建就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量，例如：

```js
var lang = "Java";
lang = lang + "Script";
```

在执行组合操作的过程中，首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"。**注意**：这个过程是在后台发生的，所以这也是在某些旧版本的浏览器（FireFox1.0以下，IE6等）中拼接字符串时速度很慢的原因。

- 3.转换为字符串

    - 1.`toString()`方法

    ```js
    var found = true;
    var foundAsString = found.toString();   //字符串“true”
    ```
    数值、布尔值、对象和字符串（返回字符串的一个副本）都有toString()方法，但null和undefined值没有。

    toString()可以传递一个参数：输出数值的基数。默认以十进制格式返回数值的字符串表示。

    - 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数`String()`，它遵循以下转换规则：
        1. 如果值由toString()方法，则调用该方法（没有参数）并返回相应的结果；
        2. 如果值是null，则返回"null"；
        3. 如果值是undefined，则返回"undefined"。

    PS:*要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（""）加在一起。*

#### 3.4.7 Object类型

对象其实就是一组数据和功能的集合。对象可以通过执行`new`操作符后跟要创建的对象类型的名称来创建。不推荐省略圆括号。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object的每个实例都具有下列属性和方法：

- Constructor：保存着用于创建当前对象的函数。

```js
var a = function(){};
var b = new a();
console.log(b.constructor);  //function a()
```

- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。作为参数的属性名（propertyName）必须以字符串形式制定。
- isPrototypeOf(object)：用于检查传入的对象是否是领域给对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in与来枚举。propertyName必须以字符串形式指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

ps:*在ECMAScript中Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法。*

ps:*ECMA-262中对象的行为不一定适用于js中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。*

---

### 3.5 操作符

操作符在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。

#### 3.5.1 一元操作符

只能操作一个值得操作符叫做一元操作符。

- 1.递增和递减操作符

在应用于不同的值时，++和--操作符遵循下列规则：

1. 在应用于包含有效数字字符的字符串时，先将其转换为数字值在执行加减1的操作，字符串变量变成数值变量；
2. 在应用于不包含有效数字字符的字符串时，将变量的值设置为NsN，字符串变量变成数值变量；
3. 在应用于布尔值false时，先将其转换为0再执行加减1的操作，布尔值变量变成数值变量；
4. 在应用于布尔值true时，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量；
5. 在应用于浮点数值时，执行加减1的操作；
6. 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值，然后对该值应用前述规则；如果结果是NaN，则再调用toString()方法后再应用前述规则，对象变量变成数值变量。

```js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};
s1++;  //值变成数值3
s2++;  //值变成数值NaN
b++;  //值变成数值1
f--;  //值变成数值0.1000000000000009(由于浮点舍入错误所致)
o--;  //值变成数值-2
```

- 2.一元加和减操作符

一元加和减操作符主要用于基本的算数运算，也可以用于转换数据类型。在转换数据类型时，以一个加号(+)或减号(-)放在变量前面，应用一元加操作符时，与递增遵循的规则一致；应用一元减操作符时，遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。

#### 3.5.2 位操作符

1. 按位非(~)：返回数值的反码；
2. 按位与(&)；
3. 按位或(|)；
4. 按位异或(^)；
5. 左移(<<)；
6. 有符号的右移(>>)；
7. 无符的号右移(>>>)；

#### 3.5.3 布尔操作符

- 1.逻辑非(!)

逻辑非都会返回一个布尔值，首先会将它的操作数转换为一个布尔值，然后再对其求反；遵循以下规则：

1. 如果操作数是一个对象，返回false；（即 Boolean({}); //true）
2. 如果操作数是一个空字符串，返回true；
3. 如果操作数是一个非空字符串，返回false；
4. 如果操作数是数值0，返回true；
5. 如果操作数是任意非0数值（包括Infinity），返回false；
6. 如果操作数是null，返回true；
7. 如果操作数是NaN，返回true；
8. 如果操作数是undefined，返回true。

ps:*！！两个逻辑非操作符会模拟Boolean()转型函数的行为，最终结果与对这个值使用Boolean()函数相同。*

- 2.逻辑与(&&)

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第二个操作数；
2. 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
3. 如果两个操作数都是对象，则返回第二个操作数；
4. 如果有一个操作数是null，则返回null；
5. 如果有一个操作数是NaN，则返回NaN；
6. 如果有一个操作数是undefined，则返回undefined。

```js
//3
var b = {} && {a:1};
console.log(b);
>>Object { a: 1 }
//6.
var aa;var bbb= (true && aa);
console.log(bbb)
>>undefined
```

`逻辑与操作属于短路操作`，即如果第一个操作数能够决定结果，那么久不会再对第二个操作数求值。对于逻辑与而言，如果第一个操作数是false，则结果必定是false，不会再对&&右侧的操作数求值了。

**注意**不能在逻辑与操作中使用未定义的值，会导致错误。

```js
var q = (true && w);
console.log(q);
>>ReferenceError: w is not defined
```

- 3.逻辑或(||)

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

1. 如果第一个操作数是对象，则返回第一个操作数；
2. 如果第一个操作数的求值结果为false，则返回第二个操作数；
3. 如果两个操作数都是对象，则返回第一个操作数；
4. 如果两个操作数都是null，则返回null；
5. 如果两个操作数都是NaN，则返回NaN；
6. 如果两个操作数都是undefined，则返回undefined。

逻辑或也是短路操作符，即如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

#### 3.5.4 乘性操作符

- 1.乘法(*)

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的乘法计算，如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity与0相乘，则结果是NaN；
4. 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
5. 如果是Infinity与Infinity相乘，则结果是Infinity；
6. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

- 2.除法(/) 被除数/除数=商

在处理特殊值的情况下，除法操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的除法计算，如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity被Infinity除，则结果是NaN；
4. 如果是0被0除，则结果是NaN；
5. 如果是非0的有限数被0除（1/0=Infinity），则结果是Infinity或-Infinity，取决于有符号操作数的符号；
6. 如果是Infinity被任何非零数值除（Infinity/1=Infinity），则结果是Infinity或-Infinity，取决于有符号操作数的符号；
7. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

- 3.求模/求余(%) 被除数/除数=余数

在处理特殊值的情况下，求模操作符遵循下列特殊的规则：

1. 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
2. 如果被除数是无穷大值而除数是有限大的数值（Infinity%0=NaN），则结果是NaN；
3. 如果被除数是有限大的数值而除数是0，则结果是NaN；
4. 如果是Infinity被Infinity除，则结果是NaN；
5. 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
6. 如果被除数是0，则结果是0；
7. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 3.5.5 加性操作符

- 1.加法(+)

如果两个操作数都是数值，执行常规的加法计算，然后根据下列规则返回结果：

1. 如果有一个操作数是NaN，则结果是NaN；
2. 如果是Infinity加Infinity，则结果是Infinity；
3. 如果是-Infinity加-Infinity，则结果是-Infinity；
4. 如果是Infinity加-Infinity，则结果是NaN；
5. 如果是+0加+0，则结果是+0；
6. 如果是-0加-0，则结果是-0；
7. 如果是+0加-0，则结果是+0。

如果有一个操作数是字符串，则应用如下规则：

1. 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来；

如果有一个操作数是对象、数值或布尔值，则调用他们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null ，则分别调用String()函数并取得字符串"undefined"和"null"。

- 2.减法(-)

减法操作在处理各种数据类型转换时，同样需要遵循一些特殊规则：

1. 如果两个操作数都是数值，则执行常规的算数减法操作并返回结果；
2. 如果有一个操作数是NaN，则结果是NaN；
3. 如果是Infinity减Infinity，则结果是NaN；
4. 如果是-Infinity减-Infinity，则结果是NaN；
5. 如果是Infinity减-Infinity，则结果是Infinity；
6. 如果是-Infinity减Infinity，则结果是-Infinity；
7. 如果是+0减+0，则结果是+0；
8. 如果是+0减-0，则结果是-0；
9. 如果是-0减-0，则结果是+0；
10. 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果是NaN；
11. 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值，如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

#### 3.5.6 关系操作符(<、>、<=、>=)

当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。相应的规则：

1. 如果两个操作数都是数值，则执行数值比较；
2. 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值；
3. 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较；
4. 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toSting()方法，并用得到的结果根据前面的规则执行比较；
5. 如果要给操作数是布尔值，则先将其转换为数值，然后再执行比较；
6. 任何操作数与NaN进行关系比较，结果都是false。

**注意1**：在比较字符串时，实际比较的是两个字符串中对应位置的字符编码值。由于大写字母的字符编码全部小于小写字母的字符编码，因此会有如下现象：

```js
var result = "Brick" < "alphabet";   //true
```

如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式再比较。

```js
var result ="Brick".toLowerCase() < "alphabet".toLowerCase();  //false
```

**注意2**：在比较两个数字字符串时，

```js
var result = "23" < "3";   //true
```

这是因为两个操作数都是字符串，“2”的字符编码（50）小于“3”的字符编码（51）。

**注意3**：在与NaN进行比较时：

```js
var result1 = NaN < 3;  //false
var result2 = NaN >= 3; //false
```

因为根据规则，任何操作数与NaN进行关系比较，结果都是false。

#### 3.5.7 相等操作符

- 1.相等和不相等(==、!=)

这两个操作符都会先转换操作数（即强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等遵循下列规则：

1. 如果有一个操作数是布尔值，则先将其转换为数值--false转换为0，true转换为1；
2. 如果有一个操作数是字符串，另一个操作数是数值，则先将字符串转换为数值；
3. 如果有一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵信下列规则：

1. null和undefined是相等的；
2. 要比较相等性之前，不能将null和undefined转换成其他任何值；
3. 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。**注意**：即使两个操作数都是NsN，相等操作符也返回false，因为按照规则，NaN不等于NaN；
4. 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则，返回false。

```js
null == undefined;  //true
"NaN" == NaN;       //false
5 == NaN;           //false
NaN == NaN;         //false
NaN != NaN;         //true
false == 0;         //true
true == 1;          //true
true == 2;          //false
undefined == 0;     //false
null == 0;          //false
"5" == 5;           //true
```

- 2.全等和不全等

在比较之前不转换操作数；

**注意1**：null == undefined 会返回true，因为他们是类似的值；但是 null === undefined 会返回false，因为他们是不同类型的值。

**注意2**：由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。

#### 3.5.8 条件操作符

```js
variable = boolean_expression ? true_value : false_value;
```

#### 3.5.9 赋值操作符(=)

如果在等于号前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作：

1. *=;
2. /=;
3. %=;
4. +=;
5. -+;
6. <<=（左移/赋值）;
7. >>=（有符号右移/赋值）;
8. >>>=（无符号右移/赋值）.

*ps：*这些操作符的主要目的就是简化赋值操作，使用他们不会带来任何性能的提升。

#### 3.5.10 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作：

```js
var num1=1, num2=2, num3=3;
```

多用于声明多个变量。在用于赋值时，逗号操作符总会返回表达式中的最后一项：

```js
var num =(5, 1, 4, 8, 0);   //num的值为0
```

---

### 3.6 语句

#### 3.6.1 if语句

if中的 condition(条件) 可以是任意表达式，而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。

#### 3.6.2 do-while 语句

do-while语句是一种`后测试循环语句`，即只有在循环体中的代码执行之后，才会测试出口条件。也就是说，在对条件表达式求值之前，循环体内的代码至少会被执行一次：

```js
var i = 0;
do {
    i+=2;
}while(i<10>);
alert(i);
```

*ps:*想do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。

#### 3.6.2 while语句

while语句属于`前测试循环语句`，即在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行：

```js
var i =0;
while(i<10){
    i +=2;
}
```

#### 3.6.4 for语句

for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。for循环也有可能不会执行循环体中的代码，但如果执行了循环体中的代码，则一定会对循环后的表达式（i++）求值，即递增i的值：

```js
for(var i=4;i<5;i++){
    console.log(i);  //4
}
console.log(i);   //5
```

可以看出，i是在执行完循环体中的代码后再执行后面表达式（i++）的。

**注意**：使用while循环做不到的，使用for循环同样做不到；因为ECMAScript中不存在块级作用于，因此在循环体内部定义的变量也可以在外部访问到。例如上例中的变量i，在循环外部仍然可以访问到它。

#### 3.6.4 for-in语句

for-in语句是一种精准的迭代语句，可以用来枚举对象的属性：

```js
for(var propName in window){
    console.log(propName);
}
```

**注意1**：ECMAScript对象的属性没有顺序，因此通过for-in循环输出的属性名的顺序是不可预测的。所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。

**注意2**：如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。ECMAScript更正了这一行为：对这种情况不再抛出错误，而只是不执行循环体。`但是，在使用for-in循环之前，先检测确认该对象的值不是null或undefined能保证最大限度地兼容性。`

#### 3.6.6 label语句

使用label语句可以在代码中添加标签，以便将来使用：

```js
start:for(var i=0;i<count;i+=1>){
    alert(i);
}
```

label语句定义的标签可以在将来由break或continue语句引用，加标签的语句一般都要与for语句等循环语句配合使用，多用于跳出多层循环：

```js
var num = 0;
  for (var i = 0 ; i < 10 ; i++){
    for (var j = 0 ; j < 10 ; j++){
     if( i == 5 && j == 5 ){
      break;
     }
    num++;
    }
  }
alert(num); // 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环，输出 95


var num = 0;
 outPoint:
 for (var i = 0 ; i < 10 ; i++){
   for (var j = 0 ; j < 10 ; j++){
    if( i == 5 && j == 5 ){
     break outPoint;
    }
   num++;
   }
 }
 alert(num); // 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行，输出 55

 var num = 0;
　　outPoint:
　　for(var i = 0; i < 10; i++) {
 　　for(var j = 0; j < 10; j++) {
  　　if(i == 5 && j == 5) {
   　　continue outPoint;
      }
  　　num++;
 　　}
　　}
　　alert(num); //95 continue outPoint;语句的作用是跳出当前循环，并跳转到outPoint（标签）下的for循环继续执行。
```

#### 3.6.7 break和continue语句

break和continue语句用于在循环中精确地控制代码的执行。break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句也会立即退出循环，但退出循环后会从循环的顶部继续执行。

#### 3.6.8 with语句

with语句的作用是将代码的作用域设置到一个特定的对象中：

```js
var qs = location.search.substring(1);
var url = location.href;

//都包含location对象，可以用with语句改写：
with(location){
    var qs = searching.substring(1);
    var url = href;
}
```

with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。

**注意**：严格模式下不允许使用with语句，否则会被视为语法错误。由于大量使用with语句会导致性能下降，同时也会给调式代码造成困难，因此在大型应用程序中，不建议使用with。

#### 3.6.9 switch语句

break关键字会让代码执行流跳出switch语句。如果省略break关键字，就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码。

通过为每个case后面都添加一个break语句，可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，一定要在代码中添加注释，说明是有意省略了break关键字：

```js
switch(i){
    case 25:
        /* 合并两种情形*/
    case 35:
        alert("25 or 35");
        break;
    case 45:
        alert("45");
        break;
    default:
        alert("Other");
}
```

switch语句中可以使用任何数据类型，无论是字符串，还是对象都可以；另外，每个case的值不一定是常量，可以是变量，甚至是表达式：

```js
switch("hello world"){
    case "hello" + "world":
        alert("1");
        break;
    case "goodbye":
        alert("2");
        break;
    default:
        alert("3");
}

var num = 25;
switch(true){
    case num<0:
        alert("less than 0.");
        break;
    case num>=0 && num <=10:
        alert("Between 0 and 10.");
        break;
    default:
        alert("More than 10.");
}
```

第二个例子中，之所以给switch语句传递表达式true，是因为每个case值都可以返回一个布尔值。这样，每个case按照顺序被求职，直到找到匹配的值或者遇到default语句为止。

**注意**：switch语句在比较值时使用的是全等操作符，因为不会发生类型转换。

---

### 3.7 函数

return语句可以不带任何返回值，在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。

**推荐**：要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候又不返回值，会给调试代码带来不便。

严格模式对函数有一些限制，如果发生一下情况，将会导致语法错误，代码无法执行：

1. 不能把函数命名为eval 或 arguments；
2. 不能把参数命名为eval 或 arguments；
3. 不能出现两个命名参数同名的情况。

#### 3.7.1 理解参数

因为ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型）。

在函数体内可以通过arguments对象来访问这个参数数组。arguments对象只是与数组类似（它并不是Array的实例），可以使用方括号语法访问他的每一个元素`arguments[0]`，使用length属性来确认传递进来多少个参数。

arguments的值永远与对应命名参数的值保持同步：

```js
function a(num1,num2){
arguments[1]=10;num1=2;console.log(arguments[0]+num2);
}
a(1,2); // 12


function b(num1,num2){
num2=10;console.log(arguments[0]+num2);
}
b(1);
console.log(num2);
// 11
// Uncaught ReferenceError: num2 is not defined at <anonymous>:5:13

function c(num1,num2){
arguments[1]=10;console.log(arguments[0]+num2);console.log(arguments);
}
c(1);
// NaN
// Arguments [0: 1, 1: 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]

function d(num1,num2){
num2=10;console.log(arguments[0]+arguments[1]);console.log(arguments);
}
d(1);
// NaN
// Arguments [0: 1, callee: ƒ, Symbol(Symbol.iterator): ƒ]

function e(num1,num2){
arguments[1]=2;console.log(arguments[0]+arguments[1]);console.log(arguments);
}
e(1);
// 3
// Arguments [0: 1, 1: 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]

function f(num1,num2){
num2=10;console.log(arguments[0]+arguments[1]);console.log(arguments);
}
f(1,2);
// 11
// Arguments(2) [1, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```

1. 因为arguments对象中的值会自动反映到对应的命名参数，所以修改arguments[1]，也就修改了num2，如a()。但这并不是说读取这两个值会访问相同的内存空间；他们的内存空间是独立的，但他们的值会同步。
2. 但这种影响是`单向的`：修改命名参数不会改变arguments中对应的值，但是根据f()测试，却不是单向的。
3. 另外，如果只传入一个参数，那么为arguments[1]设置的值不会放映到命名参数中，如c()，为命名参数设置值也不会反映到arguments中，如d()；这是因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的；但是为arguments新增设置值，是可以通过arguments方括号语法继续使用的，如e()。
4. 没有传递值得命名参数将自动被赋值undefined值，这就跟定义了变量但又没有初始化一样。
5. 命名参数在函数体内相当于局部变量，如b()。

严格模式对使用arguments对象做了一些限制：

1. 像上列c()中的对arguments[1]那样的赋值会变得无效，即使把arguments[1]设置为10，num2的值仍然是undefined；
2. 重写arguments的值会导致语法错误（代码将不会执行）。

**重点**：ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

#### 3.7.2 没有重载

ECMAScript函数不能像传统意义上那样实现重载，而其他语言中，可以为一个函数编写两个定义，只要这两个定义的`签名（接受的参数的类型和数量）`不同即可。ECMAScript没有签名，因为其参数是由包含零或多个值得数组来表示的。没有函数签名，真正的重载是不能做到的。

如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数：

```js
function a(num){console.log(num+100);return num+100;}
function a(num){console.log(num+200);return num+200;}
console.log(a(100));
// 300
// 300
```

可以看出是后者直接覆盖了前者，并且不是运行两次。

**思路**：可以通过检查传入函数中参数的类型和数量并做出不同的反应，来模拟方法的重载。

---

### 3.8 小结

ECMAScript中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必须的对象，但没有对取得输入和产出输出的机制做出规定。ECMAScript中的基本要素：

1. ECMAScript中的基本数据类型包括 Undefined、Null、Boolean、Number和String；
2. ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可以用于表示所有的数值；
3. ECMAScript中也有一种复杂的数据类型，即Object类型，该类型是这门语言中所有对象的基础类型；
4. 严格模式为这门语言中容易出错的地方施加了限制；
5. ECMAScript提供了很多与C以及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符以及赋值操作符；
6. ECMAScript也有很多流控制语句，如if语句、for语句和switch语句等；
7. 无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值；
8. 实际上，未指定返回值的函数返回的是一个特殊的undefined值；
9. ECMAScript也没有函数签名的概念，因为其函数参数是以一个包含零或多个值得数组的形式传递的；
10. 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数；
11. 由于不存在函数签名的特性，ECMAScript函数不能重载。
